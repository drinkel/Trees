\documentclass[a4paper, 12pt]{article}

\usepackage[english, russian, ukrainian]{babel} % Подключение языков
\usepackage[T1, T2A]{fontenc} % Кодировка
\usepackage[utf8]{inputenc} % Кодировка
\usepackage{geometry} % Изменение размеров страницы
\usepackage{titleps} % Главы, заголовки и т.д.
\usepackage{amsmath, amsfonts, amssymb, amsthm, mathtools} % Работа с математикой
\usepackage{dashbox} % Выделение в прямоугольник
\usepackage{colortbl} % Раскраска таблиц
\usepackage{latexsym, textcomp} % Специальные символы LaTeX
\usepackage{indentfirst} % Сделался абзац сразу после заголовка
\usepackage{fancyhdr} % Настройка колонтитулов
\usepackage{tikz, pgfplots} % Пакет для векторной графики
\usepackage{mathtext} % Русские буквы в формулах
\usepackage{mathrsfs} % Математический шрифт
\usepackage{enumitem} % Создание списков
\usepackage{multirow, rotating} % Для таблиц
\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{caption}

% Вставка кода %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstset{escapeinside={\%*}{*)},
		 language=Python,
		 backgroundcolor=\color{backcolour},   
    	 commentstyle=\color{codegreen},
    	 keywordstyle=\color{magenta},
    	 numberstyle=\color{codegray},
    	 stringstyle=\color{codepurple},
    	 basicstyle=\ttfamily\footnotesize,
    	 breakatwhitespace=false,         
    	 breaklines=false,
    	 keepspaces=false,          
    	 numbers=left,
    	 numbersep=5pt,
    	 showspaces=false,
    	 showstringspaces=false,
    	 showtabs=false,
    	 tabsize=5
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\geometry{top=20mm} % Верхний отступ (поле)
\geometry{bottom=20mm} % Нижний отступ (поле)
\geometry{left=10mm} % Левый отступ (поле)
\geometry{right=10mm} % Правый отступ (поле)

\newcommand{\x}{\bar{x}}
\renewcommand{\arraystretch}{1.5}

\title{Тестове завдання у Distributed Lab}
\author{Голубєв Кирило Дмитрович}
\date{Вересень 2024}


\begin{document}
 \maketitle
 \tableofcontents
 
 \newpage
\section{Бінарне дерево Меркла.}

\par Бінарне дерево Меркла -- це граф, кожна вершина якого має по два нащадка. У кожній вершині, яка зветься вузлом, містяться своі дані, які отримуються шляхом хешування суми хешів двох вузлів-нащадків. У БДМ подається набір даних, які називають листям, а позначимо їх $a_1, a_2, \dots, a_m$. \\

\par Так як БДМ будується знизу вверх, представимо його як список списків, що буде продемонстровано нижче. Позначимо вузли як $h_{(n, k)}$, де $n$ -- номер рядка, де знаходиться вузол (нумерація знизу вверх), а $k$ -- його порядковий номер в цьому рядку. Індексацію почнемо з $0$, як це робиться в програмуванні. Тепер, коли розібралися з позначеннями, перейдемо до представлення БДМ. Якщо маємо БДМ виду:

\[\begin{tikzpicture}
  \tikzstyle{every node}=[draw, shape=circle, thick];
  \node (v1) at (0, 0) {$h_{(2, 0)}$};
  \node (v2) at (-3, -2) {$h_{(1, 0)}$};
  \node (v3) at (3, -2) {$h_{(1, 1)}$};
  \node (v4) at (-5, -4) {$h_{(0, 0)}$};
  \node (v5) at (-1, -4) {$h_{(0, 1)}$};
  \node (v6) at (1, -4) {$h_{(0, 2)}$};
  \node (v7) at (5, -4) {$h_{(0, 3)}$};
  \draw[thick] (v7) -- (v3) -- (v1) -- (v2) -- (v4);
  \draw[thick] (v5) -- (v2);
  \draw[thick] (v6) -- (v3);
  \node[fill=lime] (a1) at (-5, -6) {$a_0$};
  \node[fill=lime] (a2) at (-1, -6) {$a_1$};
  \node[fill=lime] (a3) at (1, -6) {$a_2$};
  \node[fill=lime] (a4) at (5, -6) {$a_3$};
  \draw[thick, ->] (a1) -- (v4);
  \draw[thick, ->] (a2) -- (v5);
  \draw[thick, ->] (a3) -- (v6);
  \draw[thick, ->] (a4) -- (v7);
\end{tikzpicture}\]
 
 то в программі це буде мати вигляд:

\[\Big[ \, [h_{(0, 0)}, h_{(0, 1)}, h_{(0, 2)}, h_{(0, 3)}], \, [h_{(1, 0)}, h_{(1, 1)}], \, [h_{(2, 0)}] \, \Big] \, - \, \text{БДМ}\]

\par Знаходити батьків і нащадків теж можна. Якщо ми маємо вузол $h_{(n, k)}$ і нам треба знайти його нащадків, то вони мають вигляд $h_{(n-1, 2k)}, \, h_{(n-1, 2k+1)}$. Якщо ми маємо вузол $h_{(n, k)}$ і вимагається знайти його батька, то це робиться так:
 
\begin{itemize}
	\item якщо $k$ -- парне, то батько має вигляд $h_{(n+1, \frac k2)}$
	\item якщо $k$ -- непарне, то батько має вигляд $h_{(n+1, \frac {k-1}2)}$
\end{itemize}
 
\par У вигляді псевдокоду маємо такі функції:

\begin{lstlisting}
def neighbour_searcher(k):
	if k %*парне*):
		return k + 1
	else:
		return k - 1
\end{lstlisting}

\begin{lstlisting}
def parent_searcher(k):
    if k %*парне*):
        return k // 2
    else:
        return (k - 1) // 2
\end{lstlisting}
 
\par Для будування БДМ також треба знати заздалегідь, скільки рівнів воно буде мати. Кількість рівнів дорівнює $\left\lceil \log_2(n) \right\rceil$ (округлення догори), де $n$ -- кількість початкових даних.
\newpage

\par Почнемо будування БДМ з функції хешування, адже вона потрібна на кожному кроці. Функція бере на вхід елемент зі списку, перетворює його на рядок і хешує.
 
\begin{lstlisting}
def hash(x):
	# %*Це знадобиться для Sparse Merkle Tree*)
	if x in (None,
		    'dc937b59892604f5a86ac96936cd7ff09e25f18ae6b758e8014a24c7fa039e91',
		    2 * 'dc937b59892604f5a86ac96936cd7ff09e25f18ae6b758e8014a24c7fa039e91'):
		return 'dc937b59892604f5a86ac96936cd7ff09e25f18ae6b758e8014a24c7fa039e91'
		
 	bytes_obj = %*перетворення*) x %*на рядок*)
 	hash_obj = %*хешування*) x
 	return hash_obj
\end{lstlisting}
 
\par Далі треба задати функцію, що прийме як аргумент список початкових даних і збудує дерево. Вона перевіряє довжину списку з початковими даними на парність і робить його парним за необхідністю, хешує початкові дані і будує дерево:
 
\begin{lstlisting}
def binary_tree_builder(x):
    tree, Level, temp = [], [], x[:]

    if %*довжина*) temp %*непарна*):
        temp %*приймає свій останній елемент*)
    tree %*приймає список хешованих початкових елементів*)

    for i in range(1, math.ceil(math.log2(len(temp))) + 1):
        for j in range(0, len(BMT[i - 1]), 2):
            %*До Level додається*) hash(tree[i - 1][j] + tree[i - 1][j + 1])
        if %*довжина L*) %*непарна*) and i %*не дорівнює*) math.ceil(math.log2(len(temp))):
            %*До L додається його останній елемент*)
        tree %*приймає*) Level
        Level %*обнуляється*)
    return tree
\end{lstlisting}
 
\par Функцію будування БДМ з розширеним списком початкових даних було задано наступним чином: список початкових даних складається зі списком додаткових даних і передається у функцію будування БДМ:
 
\begin{lstlisting}
def extra_binary_tree_builder(data, extra):
	temp = data + extra
	return tree_builder(temp)
\end{lstlisting}

\subsection{Складність додавання нового елемента в БДМ.}

\par Оцінимо О()-складність. Нехай $n$ -- кількість початкових елементів, $k$ -- кількість додаткових даних. Функція \textbf{extra\_binary\_tree\_builder} повністю перебудовує дерево з новим розширеним списком початкових даних. Тому проаналізуємо складність будування БДМ зі списком із $n + k$ елементів:

\begin{itemize}
	\item Об'єднання списків займає $O(n + k)$, бо проходимо по всім двом спискам і формуємо новий;
	\item Якщо список має непарну кількість елементів, то в кінець додається останній його елемент, що має складність О(1);
	\item Хешування елементів на першому рівні займає $n + k$ розрахунків, на другому $\dfrac {n + k}2$, на третьому $\dfrac {n + k}4$, \dots;
	\item Сумарно маємо $(n + k) + \dfrac {n + k}2 + \dfrac {n + k}4 + \, \dots \, \approx 2 \cdot (n + k)$ -- кількість операцій для будування БДМ, а тому $O(2 \cdot (n + k)) = O(n + k)$.
\end{itemize}
\par Об'єднуючи обидві складності, отримуємо $O(n + k) + O(n + k) = O(n + k)$.
 
\subsection{Складність генерації доказу включення.}

\par Сутність генерації доказу включення полягає у формуванні списку із конкретних елементів БДМ. Розглянемо дерево із п'яти початкових елементів:

\[\begin{tikzpicture}
	\tikzstyle{every node}=[draw, shape=circle, thick];
	\node (v1) at (0, 0) {$h_{(3, 0)}$};
	\node (v2) at (-3.5, -2) {$h_{(2, 0)}$};
	\node[fill=brown] (v3) at (3.5, -2) {$h_{(2, 1)}$};
	\node[fill=brown] (v4) at (-5.5, -4) {$h_{(1, 0)}$};
	\node (v5) at (-1.5, -4) {$h_{(1, 1)}$};
	\node (v6) at (1.5, -4) {$h_{(1, 2)}$};
	\node (v7) at (5.5, -4) {$h_{(1, 2)}$};
	\draw[dashed, ->, thick] (v6) -- (v7) node[draw=none, shape=rectangle, midway, below] {Копія};
	\node (v8) at (-6.5, -6) {$h_{(0, 0)}$};
	\draw[thick] (v1) -- (v2) -- (v4) -- (v8);
	\draw[thick] (v2) -- (v5);
	\node (v9) at (-4.5, -6) {$h_{(0, 1)}$};
	\node (v10) at (-2.5, -6) {$h_{(0, 2)}$};
	\node[fill=brown] (v11) at (-0.5, -6) {$h_{(0, 3)}$};
	\node (v12) at (0.75, -7.5) {$h_{(0, 4)}$};
	\node (v13) at (3.75, -7.5) {$h_{(0, 4)}$};
	\draw[dashed, ->, thick] (v12) -- (v13) node[draw=none, shape=rectangle, midway, below] {Копія};
	\draw[thick] (v9) -- (v4) (v10) -- (v5) -- (v11) (v12) -- (v6) -- (v13) (v7) -- (v3) -- (v6) (v3) -- (v1);
	\node[fill=lime] (a1) at (-6.5, -9) {$a_0$};
	\node[fill=lime] (a2) at (-4.5, -9) {$a_1$};
	\node[fill=lime] (a3) at (-2.5, -9) {$a_2$};
	\node[fill=lime] (a4) at (-0.5, -9) {$a_3$};
	\node[fill=lime] (a5) at (0.75, -9) {$a_4$};
	\draw[thick, dashed, ->] (a1) -- (v8) (a2) -- (v9) (a3) -- (v10) (a4) -- (v11) (a5) -- (v12);
\end{tikzpicture}\]
	
\par Для прикладу сформуємо доведення для $a_3$. На першому кроці знаходимо хеш сусіднього елемента і додаємо до списку $Proof$, далі знаходимо сусіда до батька і додаємо у список і так поки не дійдемо до передостаннього рівня дерева (потрібні елементи позначені коричневим). Як результат отримуємо список:
	
	\[Proof_{a_2} = \left[h_{(0, 3)}, \ h_{(1, 0)}, \ h_{(2, 1)}\right]\]

\par Будемо вважати, що BMT -- збудоване за \textbf{binary\_tree\_builder(leaves)} дерево. Тоді у вигляді псевдокоду це виглядає наступним чином:
	
\begin{lstlisting}
def binary_tree_mp(x):
    proof, n, k = [], 0, 0

    for i in range(len(leaves)):
        if x == %*i-й елемент із*) leaves:
            k = i
        else:
            for i in range(1, len(BMT)):
                for j in range(len(BMT[i])):
                    if x == %*j-й елемент із і-го рівня*) BMT:
                        n, k = i, j

    proof %*приймає сусідній до k-го елемента на рівні n*) BMT
    for i in range(n + 1, len(BMT) - 1):
        proof %*приймає батька для елемента k з рівня n*) BMT
        for j in range(len(BMT[i])):
            if %*останній елемент*) proof == %*j-й елемент з рівня і*) BMT:
                k = j
    return proof
\end{lstlisting}

\par Для розуміння складності генерації доказу включення розглянемо детальніше алгоритм його створення. Нам треба пройтись по дереву і зібрати потрібні хеші по одному з кожного рівня, а рівнів в БДМ $\left\lceil \log_2(n)\right\rceil$, де $n$ -- кількість листів. Тоді і $O() = O(log(n))$.

\subsection{Розмір доказу включення.}

\par Якщо треба знайти розмір списку (чим за сутністю і є доказ включення) у байтах, переведемо кожний елемент списку у рядок і окремо підрахуємо кількість байтів, а саме:

\begin{lstlisting}
# %*Розмір у байтах елемента*)
def bytesize(x):
    string = str(x).encode('utf-8')
    return %*довжина*) string

# %*Підрахунок розміру списку*)
def proofsize(x):
    size = 0
    for i in range(len(x)):
        size = size + bytesize(x[i])
    return size
\end{lstlisting}

\par Так як доказ формується шляхом збору одного хеша на кожному рівні БДМ, окрім останнього, то всього хешів у доведенні буде $\left\lceil \log_2(n)\right\rceil - 1$. Кожен хеш це 64 байта, тому довжина доказу у загальному випадку дорівнює $64 * \big(\left\lceil \log_2(n)\right\rceil - 1\big)$.
	
\subsection{Складність верифікації доказу включення.}
\par Для верифікації доказу включення нам треба лише пройтись по дереву і виконувати хешування елементів на кожному рівні. Візуально це виглядає наступним чином (на прикладі $a_3$):

\[\resizebox{0.6\textwidth}{!}{
\begin{tikzpicture}
	\tikzstyle{every node}=[draw, shape=circle, thick];
	\node (v1) at (0, 0) {$h_{(3, 0)}$};
	\node[fill=orange] (v2) at (-3.5, -2) {$h_{(2, 0)}$};
	\node[fill=brown] (v3) at (3.5, -2) {$h_{(2, 1)}$};
	\node[fill=brown] (v4) at (-5.5, -4) {$h_{(1, 0)}$};
	\node[fill=orange] (v5) at (-1.5, -4) {$h_{(1, 1)}$};
	\node (v6) at (1.5, -4) {$h_{(1, 2)}$};
	\node (v7) at (5.5, -4) {$h_{(1, 2)}$};
	\draw[dashed, ->, thick] (v6) -- (v7) node[draw=none, shape=rectangle, midway, below] {Копія};
	\node (v8) at (-6.5, -6) {$h_{(0, 0)}$};
	\draw[thick] (v1) -- (v2) -- (v4) -- (v8);
	\draw[thick] (v2) -- (v5);
	\node (v9) at (-4.5, -6) {$h_{(0, 1)}$};
	\node[fill=orange] (v10) at (-2.5, -6) {$h_{(0, 2)}$};
	\node[fill=brown] (v11) at (-0.5, -6) {$h_{(0, 3)}$};
	\node (v12) at (0.75, -7.5) {$h_{(0, 4)}$};
	\node (v13) at (3.75, -7.5) {$h_{(0, 4)}$};
	\draw[dashed, ->, thick] (v12) -- (v13) node[draw=none, shape=rectangle, midway, below] {Копія};
	\draw[thick] (v9) -- (v4) (v10) -- (v5) -- (v11) (v12) -- (v6) -- (v13) (v7) -- (v3) -- (v6) (v3) -- (v1);
	\node (a1) at (-6.5, -9) {$a_0$};
	\node (a2) at (-4.5, -9) {$a_1$};
	\node[fill=lime] (a3) at (-2.5, -9) {$a_2$};
	\node (a4) at (-0.5, -9) {$a_3$};
	\node (a5) at (0.75, -9) {$a_4$};
	\draw[thick, dashed, ->] (a1) -- (v8) (a2) -- (v9) (a3) -- (v10) (a4) -- (v11) (a5) -- (v12);
\end{tikzpicture}
}\]

\begin{eqnarray*}
	\underbrace{\text{hash}(h_{(0, 2)} + h_{(0, 3)})}_{h_{(1, 1)}} \ \rightarrow \ \underbrace{\text{hash}(h_{(1, 0)} + h_{(1, 1)})}_{h_{(2, 0)}} \ \rightarrow \ \underbrace{\text{hash}(h_{(3, 1)} + h_{(3, 2)})}_{\text{root}}
\end{eqnarray*}

\par Порівнюємо $\text{hash}(h_{(2, 0)} + h_{(2, 1)})$ із коренем і якщо вони співпадають, то доказ успішно підтверджено. Код для верифікації має вигляд:


\begin{lstlisting}
def binary_proof_verification(x, y):
    L, n = [], 0
    
    for i in range(len(leaves)):
        if x == %*i-й елемент*) leaves:
            n = 0
            L %*приймає*) hash(x)

    for i in range(1, len(BMT)):
        for j in range(len(BMT[i])):
            if x == %*j-й елемент на і-му рівні*) BMT:
                n = i
                L %*приймає*) x

    if len(L) == 0:
        return '%*Немає такого елемента в дереві.*)'

    if n == 0:
        for i in range(len(y)):
            for j in range(len(BMT[i])):
                if %*i-й елемент*) y == %*j-й елемент на і-му рівні*) BMT and j %*парний*):
                    L %*приймає*) hash(%*і-й елемент*) y + %*i-й елемент*) L)
                    break
                elif %*i-й елемент*) y == %*j-й елемент на і-му рівні*) BMT and j %*непарний*):
                    L %*приймає*) hash(%*i-й елемент*) L + %*i-й елемент*) y)
                    break
    else:
        for i in range(n, len(y) + 1):
            for j in range(len(BMT[i])):
                if %*i-n елемент*) y == %*j-й елемент на і-му рівні*) BMT and j %*парний*):
                    L %*приймає*) hash(%*i-n елемент*) y + %*останній елемент*) L)
                    break
                elif %*i-n елемент*) y == %*j-й елемент на і-му рівні*) BMT and j %*непарний*):
                    L %*приймає*) hash(%*останній елемент*) L + %*i-n елемент*) y)
                    break

    if %*останній елемент*) L == %*корінь*) BMT:
        return True
    else:
        return False
\end{lstlisting}

\par Для аналізу складності пройдемось по кожному етапу коду:

\begin{itemize}
	\item Пошук елемента в \textbf{leaves} займає не більше ніж $O(n)$, де $n$ -- кількість елементів в \textbf{leaves};
	\item Пошук елемента на інших рівнях БДМ займає $\dfrac n2,\, \dfrac n4,\, \dfrac n8,\, \dots$, в сумі маємо $\dfrac n2 + \dfrac n4 + \dfrac n8 + \, \dots = n$, а отже $O(n)$;
	\item Перевірка доказу і формування списку $L$ в найгіршому випадку займе $2 \cdot n$ часу (пройдемо по всім рівням і всім елементам), тому $O(2 \cdot n) = O(n)$;
	\item Звірка кореня БДМ з останнім елементом $L$ має складність $O(1)$.
\end{itemize}

\par Як результат, маємо $O(n) + O(n) + O(n) + O(1) = O(n)$

\section{Розріджене дерево Меркла.}
\par Основна відмінність розрідженого дерева Меркла від бінарного в тому, що у РДМ завжди однакова кількість елементів, абсолютна більшість з яких -- порожні. Так як ми використовуємо sha256 для хешування, перший рівень РДМ має $2^{256}$ елементів, більшість з яких, знову таки, порожні. Рівнів у РДМ 256, а загальна кількість елементів:
\[\sum_{j = 1}^{256} 2^j = 2^{256 - 1} - 1\]
\par що є дуже великою кількістю, щоб зберігати все дерево у пам'яті комп'ютера, і підрахунок більшості з елементів ніяк не впливає на дерево, але займає великий час. Тому при роботі з РДМ використовують різні методи зберігання лише тієї частини дерева, що використовується. Ми зробимо наступне:

\begin{itemize}
	\item зрозуміємо, скільки елементів із першого рівня можна відкинути, щоб дерево не змінилось;
	\item сформуємо список із отриманих елементів;
	\item побудуємо БДМ, взявши отриманий список як початкові дані;
	\item зрозуміємо, скільки разів треба захешувати суму кореня отриманого БДМ з хешем None;
	\item отримуємо корінь РДМ.
\end{itemize}

\par Почнемо з першого пункту. Якщо маємо $n$ початкових елементів, то нам треба, щоб список мав у собі $2^{\left\lceil \log_2(n)\right\rceil}$ елементів. Тобто:

\[\big[\underbrace{a_0, \, a_1, \, a_2, \, \dots, \, a_{n - 1}, \, \text{None}, \, \text{None}, \, \dots, \, \text{None}}_{2^{\left\lceil\log_2(n)\right\rceil}}\big]\]

\par Інші $2^{256} - 2^{\left\lceil\log_2(n)\right\rceil}$ можна відкинути, вони не впливають на дерево, окрім кореня. Це і буде список листків, на яких побудуємо БДМ. Це дерево має висоту $\left\lceil\log_2(n)\right\rceil$. Для того, щоб отримати корінь РДМ, треба виконати наступне:

\begin{lstlisting}
for i in range(math.ceil(math.log2(n)), 256):
	root = hash(root + hash(None))
\end{lstlisting}

\par Таким чином, у пам'яті зберігається лише потрібна частина РДМ, а нульові елементи, яких величезна кількість, але які ніяк не впливають на хеші, відкидаються. Код для побудови РДМ виглядає наступним чином:

\begin{lstlisting}
def sparse_tree_builder(x):
    height = %*найближча степінь, у яку треба піднести 2 щоб отримати*) len(x)
    L = [None] * (2**height)
    
    for i in range(len(x)):
        %*i-й елемент*) L = %*i-й елемент*) x
    
    SMT = binary_tree_builder(L)
    root = SMT[-1][-1]
    j = len(binary_tree_builder(L))
    
    while j < 256:
        if j == 255:
            root = hash(root + hash(None))
            SMT %*приймає*) root
        else:
            root = hash(root + hash(None))
            SMT %*приймає*) [root, hash(None)]
        j %*збільшується на*) 1
        
    return SMT
\end{lstlisting}

\par Візуально зобразити РДМ теж доволі складно, знову таки через величезну кількість елементів. Але можна зобразити тільки ту частину, з якою працюємо, а саме:

\begin{itemize}
	\item Розширений список початкових даних;
	\item БДМ, збудоване на цьому списку;
	\item "Башта" \, виду [елемент, hash(None)];
	\item Корінь РДМ.
\end{itemize}

\par Нехай маємо 5 листів. Тоді розширений список початкових даних повинен складатися з $2^{\left\lceil\log_2(5)\right\rceil} = 2^3 = 8$ елементів, а саме:

\[\big[a_0, \ a_1, \ a_2, \ a_3, \ a_4, \ \text{None}, \ \text{None}, \ \text{None}\big]\]

\[\resizebox{0.8\textwidth}{!}{
\begin{tikzpicture}
	\tikzstyle{every node}=[draw, shape=circle, thick];
	\node (v1) at (0, 0) {$h_{(255, 0)}$};
	\node (v2) at (-3.5, -2) {$h_{(254, 0)}$};
	\node[fill=cyan] (v3) at (3.5, -2) {$h_{(254, 1)}$};
	\node[draw=none, shape=circle] (w1) at (2, -4) {$\dots$};
	\node[draw=none, shape=circle] (w2) at (5, -4) {$\dots$};
	\draw (v1) -- (v3) (w1) -- (v3) -- (w2);
	
	\node (v4) at (-6, -4) {$h_{(253, 0)}$};
	\node[fill=cyan] (v5) at (-1, -4) {$h_{(253, 1)}$};
	\draw (v1) -- (v2) -- (v4) (v2) -- (v5);
	\node[draw=none, shape=circle] (w3) at (-7.5, -6) {$\dots$};
	\node[draw=none, shape=circle] (w4) at (-4.5, -6) {$\dots$};
	\draw (w3) -- (v4) -- (w4);
	
	\node[draw=none, shape=circle] (w5) at (-2.5, -6) {$\dots$};
	\node[draw=none, shape=circle] (w6) at (0.5, -6) {$\dots$};
	\draw (w5) -- (v5) -- (w6);
	
	\node (v6) at (-13.5, -8) {$h_{(3, 0)}$};
	\node[fill=cyan] (v7) at (-6, -8) {$h_{(3, 1)}$};
	\draw (v6) -- (w3) -- (v7);
	
	\node (v8) at (-17, -10) {$h_{(2, 0)}$};
	\node (v9) at (-10, -10) {$h_{(2, 1)}$};
	\node[draw=none, shape=circle] (w7) at (-4.5, -10) {$\dots$};
	\draw (v8) -- (v6) -- (v9) (v7) -- (w7);
	
	\node (v10) at (-19, -12) {$h_{(1, 0)}$};
	\node (v11) at (-15, -12) {$h_{(1, 1)}$};
	\draw (v10) -- (v8) -- (v11);
	\node (v12) at (-12, -12) {$h_{(1, 2)}$};
	\node[fill=cyan] (v13) at (-8, -12) {$h_{(1, 3)}$};
	\draw (v12) -- (v9) -- (v13);
	
	\node (v14) at (-19.75, -14) {$h_{(0, 0)}$};
	\node (v15) at (-18.25, -14) {$h_{(0, 1)}$};
	\node (v16) at (-15.75, -14) {$h_{(0, 2)}$};
	\node (v17) at (-14.25, -14) {$h_{(0, 3)}$};
	\node (v18) at (-12.75, -14) {$h_{(0, 4)}$};
	\node[fill=cyan] (v19) at (-11.25, -14) {$h_{(0, 5)}$};
	\node[fill=cyan] (v20) at (-8.75, -14) {$h_{(0, 6)}$};
	\node[fill=cyan] (v21) at (-7.25, -14) {$h_{(0, 7)}$};
	\draw (v14) -- (v10) -- (v15) (v16) -- (v11) -- (v17) (v18) -- (v12) -- (v19) (v20) -- (v13) -- (v21);
	
	\node[fill=lime] (a1) at (-19.75, -15.5) {$a_0$};
	\node[fill=lime] (a2) at (-18.25, -15.5) {$a_1$};
	\node[fill=lime] (a3) at (-15.75, -15.5) {$a_2$};
	\node[fill=lime] (a4) at (-14.25, -15.5) {$a_3$};
	\node[fill=lime] (a5) at (-12.75, -15.5) {$a_4$};
	\node[fill=lime] (a6) at (-11.25, -15.5) {$\text{None}$};
	\node[fill=lime] (a7) at (-8.75, -15.5) {$\text{None}$};
	\node[fill=lime] (a8) at (-7.25, -15.5) {$\text{None}$};
	
	\draw[->, thick] (a1) -- (v14);
	\draw[->, thick] (a2) -- (v15);
	\draw[->, thick] (a3) -- (v16);
	\draw[->, thick] (a4) -- (v17);
	\draw[->, thick] (a5) -- (v18);
	\draw[->, thick] (a6) -- (v19);
	\draw[->, thick] (a7) -- (v20);
	\draw[->, thick] (a8) -- (v21);
\end{tikzpicture}
}\]

\par Зелені дані -- початкові дані (листя), сині -- нульові елементи.

\subsection{Складність додавання нового елемента в РДМ.}

\par Для розрахунку складності додавання нового елемента проаналізуємо код поетапно:

\begin{itemize}
	\item Формування порожнього списку $L$ має довжину $2^{\lceil \log_2(n) \rceil}$, де $n$ -- кількість початкових даних. Довжина $L$ не більше ніж у $2$ рази більша за $n$ ($n = 3 \, \Rightarrow \, 2^{\lceil \log_2(n) \rceil}  = 4, \ \ n = 5 \, \Rightarrow \, 2^{\lceil \log_2(n) \rceil} = 8, \ \ n = 478 \, \Rightarrow \, 2^{\lceil \log_2(n) \rceil}  = 512$), тому $O() \approx O(2 \cdot n) = O(n)$.
	\item Заміна елементів $L$ елементами з $x$ (leaves по суті) займає $O(n)$ часу, бо в $x$ $n$ елементів;
	\item Побудова БДМ зі списку $L$ займає $O(n)$ часу (те ж саме додавання елемента в бінарне дерево, але $k = 0$);
	\item Хешування кореня БДМ з hash(None) виконується $256 - \lceil \log_2(n) \rceil$ раз, тоді \\ $O\big(256 - \lceil \log_2(n) \rceil\big) \le O(256 - \log_2(n)) \le O(256) = O(1)$;
	\item Кінцева складність побудови РДМ $O(n) + O(n) + O(n) + O(1) = O(n)$.
\end{itemize}
\par Додавання нових елементів у РДМ супроводжується повним перерахунком усього дерева, тобто складність формування розширеного списку це $O(n + k)$, складність формування РДМ на цьому списку теж $O(n + k)$, тоді складність додавання нових елементів у РДМ $O(n + k) + O(n + k) = O(n + k)$.

\subsection{Складність генерації доказу включення.}

\par Генерація доказу включення для РДМ майже нічим не відрізняється від генерації доказу включення, навіть код буде використано дуже схожий. Єдина різниця -- нам треба у доказ (що є списком хешів) додати певну кількість нульових хешів. Потреба цієї дії випливає з малюнку РДМ -- збудували БДМ на розширеному списку початкових даних і далі для отримання кореня РДМ хешуємо корінь БДМ з нульовим хешем певну кількість разів. Ось це і треба врахувати при формуванні доказу включення для РДМ. Код має вигляд:

\begin{lstlisting}
def sparse_tree_mp(x):
    proof, n, k, found = [], 0, 0, False
    l = %*копія*) leaves + [None] * (%*найближча степінь 2 до*) len(leaves) - len(leaves))
    tree = binary_tree_builder(l)
    
    for i in range(len(leaves)):
        if x == %*i-й елемент*) leaves:
            k = i
            found = True
            break
        else:
            for i in range(1, len(tree)):
                for j in range(len(tree[idx])):
                    if x == %*j-й елемент на і-му рівні*) tree:
                        n, k = i, j
                        found = True
                        break
    if not found:
        return None
    else:
        proof %*приймає сусіда до k-го елемента на рівні n*) tree
        for i in range(n + 1, len(tree) - 1):
            proof %*приймає батька до k-го елемента на рівні n*) tree
            for j in range(len(tree[i])):
                if %*останній елемент*) proof == %*j-й елемент на і-му рівні*) tree:
                    k = j
    
        for i in range(len(tree) - 1, 256):
            proof %*приймає*) hash(None)   
        return proof
\end{lstlisting}

\par Говорячи про складність генерації доказу включення, маємо наступне:

\begin{itemize}
	\item Копіювання списку листів займає $O(n)$, додавання порожніх елементів $\approx O(n)$, тоді для цього кроку маємо $O(n)$;
	\item Побудова БДМ займає $O(n)$;
	\item Пошук елемента в листі або на інших рівнях дерева все був проаналізований і займає $O(n)$;
	\item Формування доказу займає $O(\log(n))$, бо в гіршому випадку проходимо по кожному рівню дерева і забираємо по одному елементу;
	\item Додавання порожніх елементів теж було проаналізоване і займає $O(1)$.
\end{itemize}
\par Як результат, маємо $O(n) + O(n) + O(n) + O(\log(n)) + O(1) = O(n + \log(n))$.


\subsection{Розмір доказу включення.}
\par Доказ включення -- це список хешів. Як вже було з'ясовано, один хеш має довжину 64 байта, а доказ включення для РДМ завжди містить 255 елементів, то і довжина фіксована, а саме $64 * 255 = 16320$ байт.

\subsection{Складність верифікації доказу включення.}

\par Верифікація доказу включення для РДМ суттєво мало чим відрізняється від аналогічного для БДМ. У функцію верифікації передається елемент, наявність якого підтверджуємо, і сформований доказ для нього. Копіюємо листя і доповнюємо його елементами None до найближчої степені двійки, будуємо БДМ на цьому списку. Далі шукаємо наш елемент спочатку в листі, а потім на інших рівнях (якщо не знайшли у листі). Якщо після всього пошуку в $L$ немає елементів, то поданого у функцію значення в дереві немає. А далі все залежить від того на якому рівні було знайдено наш елемент, але алгоритм майже однаковий -- певну кількість раз складаємо і хешуємо елементи із дерева і \textbf{sparse\_tree\_mp} в певній послідовності, а потім хешуємо суму останнього елемента із L з hash(None) len(Tree) - len(sparse\_tree\_mp) раз. У вигляді коду маємо наступне:

\begin{lstlisting}
def sparse_proof_verification(x, y):
    if y == None:
        return None
    
    L, n = [], 0
    
    l = %*копія*) leaves + [None] * (%*найближча степінь 2 до*) len(leaves) - len(leaves))
    tree = binary_tree_builder(l)
    
    for i in range(len(leaves)):
        if x == %*i-й елемент*) leaves:
            n = 0
            L %*приймає*) hash(x)
    
    if len(L) == 0:
        for i in range(len(SMT)):
            for j in range(len(%*i-й рівень*) SMT)):
                if x == %*j-й елемент на і-му рівні*) SMT:
                    n = i
                    L %*приймає*) x
    else:
        pass
    
    if len(L) == 0:
        return '%*Немає такого елемента в дереві.*)'
    
    if n == 0:
        for i in range(len(tree)):
            for j in range(len(%*i-й рівень*) tree)):
                if %*i-й елемент*) y == %*j-й елемент на і-му рівні*) tree and j %*парний*):
                    L %*приймає*) hash(%*i-й елемент*) y + %*i-й елемент*) L)
                    break
                elif %*i-й елемент*) y == %*j-й елемент на і-му рівні*) tree and j %*непарний*):
                    L %*приймає*) hash(%*i-й елемент*) L + %*i-й елемент*) y)
                    break
    else:
        for i in range(n, len(tree) + 1):
            for j in range(len(%*i-й рівень*) SMT)):
                if %*i - n елемент*) y == %*j-й елемент на і-му рівні*) SMT and j %*парний*):
                    L %*приймає*) hash(%*i - n елемент*) y + %*останній елемент*) L)
                    break
                elif %*i - n елемент*) y == %*j-й елемент на і-му рівні*) SMT and j %*непарний*):
                    L %*приймає*) hash(%*останній елемент*) L + %*i - n елемент*) y)
                    break
    
    for i in range(len(tree), len(y)):
        L %*приймає*) hash(%*i - 1 елемент*) L + hash(None))
        
    if %*останній елемент*) L == %*корінь*) SMT:
        return True
    else:
        return False
\end{lstlisting}

\par Для оцінки складності проаналізуємо код покроково:

\begin{itemize}
	\item Перевірка $y$ на порожність і оголошення змінних має складність $O(1)$;
	\item Формування списку $l$ вже було проаналізоване і має складність $O(n)$, як і будування БДМ на цьому списку. Кінцева складність для цього етапу $O(n) + O(n) = O(n)$;
	\item Пошук елемента в листі має складність $O(n)$, а пошук на інших рівнях займає $O(\log(n))$ для проходу по кожному рівню і $O(n)$ для проходу по всім елементам рівня, отже кінцева складність для пошуку елемента в гіршому випадку становить $O(n) + O(\log(n)) + O(n) = O(n + \log(n))$;
	\item Перевірка $L$ на порожність займає $O(1)$;
	\item Проходження по дереву і хешування в гіршому випадку відбувається з самого листя і до кореня, а робиться одна операція на одному рівні, тому складність становить $O(\log(n))$;
	\item Хешування елемента з $L$ з hash(None) має складність $O(1)$, як було з'ясовано вище;
	\item Звірка елементів займає $O(1)$.
\end{itemize}
\par Як кінцевий результат маємо $O(1) + O(n) + O(n) + O(1) + O(\log(n)) + O(1) + O(1) = O(n + \log(n))$.


\section{Індексоване дерево Меркла.}
\par Індексоване дерево Меркла (ІДМ) схоже на БДМ за вийнятком того, що якщо в БДМ для елемента не знаходилось пари для хешування їх суми, то він дублювався і додавався в кінець списку, а в ІДМ "одинокий" елемент просто переноситься без змін на наступний рівень. Також відмінність у тому, що за кожним елементом закріплений свій індекс, що спрощує взаємодію з деревом і окремими елементами. Візуалізуємо невелике дерево для наочності.

\par Нехай є список листів $\text{leaves} = [a_0, \, a_1, \, a_2, \, a_3, \, a_4, \, a_5, \, a_6]$. Тоді у хешованому вигляді будемо мати перший рівень дерева 
\[\Big[ \, \big[h_{(0, 1)},\, [0]\big],\, \big[h_{(0, 1)},\, [1]\big],\, \big[h_{(0, 2)},\, [2]\big],\, \big[h_{(0, 3)},\, [3]\big],\, \big[h_{(0, 4)},\, [4]\big],\, \big[h_{(0, 5)},\, [5]\big],\, \big[h_{(0, 6)},\, [6]\big] \,\Big]\]

\par Наступні рівні формуються так само як і раніше, тільки враховуємо індекси, які змінюються наступним чином:
\[h_{(1, 0)} = \big[\underbrace{\text{hash}(h_{(0, 0)} + h_{(0, 1)})}_{\text{Новий елемент ІДМ}},\, \underbrace{[0, 1]}_{\text{Індекс}}\big], \ \ \ \ h_{(1, 1)} = \big[\underbrace{\text{hash}(h_{(0, 2)} + h_{(0, 3)})}_{\text{Новий елемент ІДМ}},\, \underbrace{[2, 3]}_{\text{Індекс}}\big]\]
\[h_{(2, 0)} = \big[\underbrace{\text{hash}(h_{(1, 0)} + h_{(1, 1)})}_{\text{Новий елемент ІДМ}},\, \underbrace{[0, 1, 2, 3]}_{\text{Індекс}}\big]\]

\par Для візуалізації ІДМ опустимо написи $h_{(n, k)}$, а запишемо лише індекси:

\[\begin{tikzpicture}
	\tikzstyle{every node}=[draw, shape=circle, thick];
	\node (v1) at (0, 0) {$[0, 1, 2, 3, 4, 5, 6]$};
	\node (v2) at (-4, -3) {$[0, 1, 2, 3]$};
	\node (v3) at (4, -3) {$[4, 5, 6]$};
	\draw[thick] (v3) -- (v1) -- (v2);
	
	\node (v4) at (-6, -5) {$[0, 1]$};
	\node (v5) at (-2, -5) {$[2, 3]$};
	\node (v6) at (2, -5) {$[4, 5]$};
	\node (v7) at (6, -5) {$[6]$};
	\draw[thick] (v4) -- (v2) -- (v5) (v6) -- (v3) -- (v7);
	
	\node (v8) at (-7, -6.5) {$[0]$};
	\node (v9) at (-5, -6.5) {$[1]$};
	\node (v10) at (-3, -6.5) {$[2]$};
	\node (v11) at (-1, -6.5) {$[3]$};
	
	\node (v12) at (1, -6.5) {$[4]$};
	\node (v13) at (3, -6.5) {$[5]$};
	
	\node (v14) at (6, -6.5) {$[6]$};
	\draw[thick] (v8) -- (v4) -- (v9) (v10) -- (v5) -- (v11) (v12) -- (v6) -- (v13) (v14) -- (v7);
	
	\node[fill=lime] (a1) at (-7, -8) {$a_0$};
	\node[fill=lime] (a2) at (-5, -8) {$a_1$};
	\node[fill=lime] (a3) at (-3, -8) {$a_2$};
	\node[fill=lime] (a4) at (-1, -8) {$a_3$};
	\node[fill=lime] (a5) at (1, -8) {$a_4$};
	\node[fill=lime] (a6) at (3, -8) {$a_5$};
	\node[fill=lime] (a7) at (6, -8) {$a_6$};
	
	\draw[->, thick] (a1) -- (v8);
	\draw[->, thick] (a2) -- (v9);
	\draw[->, thick] (a3) -- (v10);
	\draw[->, thick] (a4) -- (v11);
	\draw[->, thick] (a5) -- (v12);
	\draw[->, thick] (a6) -- (v13);
	\draw[->, thick] (a7) -- (v14);
\end{tikzpicture}\]

\par Код для побудови ІДМ з заданими початковими даними виглядає наступним чином:

\begin{lstlisting}
def indexed_tree_builder(x):
    tree, Level = [], []
    for i in range(len(x)):
        Level %*приймає*) [hash(%*і-й елемент*) x), [i]]
    
    tree %*приймає*) Level
    for i in range(1, math.ceil(math.log2(len(x))) + 1):
        Level = []
        
        for j in range(0, 2 * math.floor(len(tree[i - 1]) / 2), 2):
            Level %*приймає*) [hash(%*0-вий елемент j-го списку на i-1 рівні*) tree + 
            %*0-вий елемент j+1-го списку на i-1 рівні*) tree), [%*об'єднання їх індексів*)]]
        
        if len(%*і-1 -й рівень*) tree) %*непарна*):
            Level %*приймає*) (%*останній елемент і-1 -го рівня*) tree)
        else:
            pass
        
        tree %*приймає*) Level

    return tree
\end{lstlisting}

\newpage

\subsection{Складність додавання нового елемента в ІДМ.}
\par Додавання нового елемента в ІДМ відбувається абсолютно так само, як і в БДМ/РДМ -- формується новий список із листя і додаткових даних і він передається у \textbf{indexed\_tree\_builder}. У вигляді коду маємо наступне:

\begin{lstlisting}
def extra_indexed_tree_builder(data, extra_data):
    l = [%*об'єднання списків data i extra\_data*)]
    return indexed_tree_builder(l)
\end{lstlisting}

\par Для оцінки складності розберемо покроково алгоритм:
\begin{itemize}
	\item Хешування всіх елементів списку і додавання їх індексів має складність $O(n)$;
	\item При формуванні нового рівня кількість елементів зменшується приблизно в 2 рази, тому складність буде $O(n) + O\left(\dfrac n2\right) + O\left(\dfrac n4\right) + \, \dots \, = O(2 \cdot n) = O(n)$;
	\item Кінцева складність будування дерева зі списку із $n$ елементів буде $O(n) + O(n) = O(n)$;
	\item Якщо треба додати $k$ нових елементів, то формування нового списку із листів і додаткових даних має складність $O(n + k)$ і побудова дерева на такому списку буде мати складність $O(n + k)$, тому кінцева складність додавання нових елементів має вигляд $O(n + k) + O(n + k) = O(n + k)$.
\end{itemize}

\subsection{Складність генерації доказу включення.}
\par Генерація доказу включення для ІДМ має майже ту ж саму структуру, що і для БДМ, але треба враховувати "одинокі" \, елементи. Це не дуже змінює код, але зауважити треба. Сам код:

\begin{lstlisting}
def indexed_tree_mp(x):
    proof, n, k = [], 0, 0
    
    if len(leaves) %*непарна*) and x == %*останній елемент*) leaves:
        k = len(leaves) - 1
        while len(%*індекс останнього елемента на n+1 рівні*) IMT) == 1:
            n %*збільшується на*) 1
            k = len(%*n-й рівень*) IMT) - 1
    else:
        for i in range(len(leaves)):
            if x == %*і-й елемент*) leaves:
                k = i
                break
            else:
                for i in range(1, len(IMT)):
                    for j in range(len(%*і-й рівень*) IMT)):
                        if x == %*перший елемент j-го списку на i-му рівні*) IMT:
                            n, k = i, j
    
    proof %*приймає сусіда до k-го елемента на n рівні*) IMT

    for i in range(n + 1, len(IMT) - 1):
        proof %*приймає батька k-го елемента на і-му рівні*) IMT
        for j in range(len(IMT[i])):
            if %*0-й елемент останнього списку*) proof == %*0-й елемент j-го списку на і-му рівні*) IMT:
                k = j

    return proof
\end{lstlisting}

\par Для оцінки складності розберемо покроково алгоритм:
\begin{itemize}
	\item В найгіршому випадку треба пройти всі рівні дерева, що має складність $O(\log(n))$ і всі елементи на кожному рівні, тобто $O(n)$;
	\item Для формування доказу в найгіршому випадку треба пройтись по кожному рівню дерева і зібрати по одному хешу на кожному, що має складність $O(\log(n))$.
\end{itemize}
\par Кінцева складність становить $O(n) + O(\log(n)) + O(\log(n)) = O(n + \log(n))$.

\subsection{Розмір доказу включення.}
\par Доказ включення може мати різний розмір через "одинокі" \, елементи. Як можна побачити на малюнку ІДМ, для доказу наявності елементу з індексом $6$ достатньо двох хешів, а для доказу елемента з індексом $3$ -- три хеші. Якщо розглянути дерево з п'яти початковими даними, то будемо мати:

\[\begin{tikzpicture}
	\tikzstyle{every node}=[draw, shape=circle, thick];
	\node (w1) at (1, 3) {$[0, 1, 2, 3, 4]$};
	
	\node (v1) at (-2, 0) {$[0, 1, 2, 3]$};
	\node (v2) at (-4, -3) {$[0, 1]$};
	\node (v3) at (0, -3) {$[2, 3]$};
	\node (v4) at (4, -3) {$[4]$};
	\draw[thick] (v2) -- (v1) -- (v3);
	
	\node (v5) at (-5.25, -5) {$[0]$};
	\node (v6) at (-3.25, -5) {$[1]$};
	\node (v7) at (-1.25, -5) {$[2]$};
	\node (v8) at (1.25, -5) {$[3]$};
	\node (v9) at (4, -5) {$[4]$};
	\draw[thick] (v5) -- (v2) -- (v6) (v7) -- (v3) -- (v8);
	
	\node (v10) at (4, 0) {$[4]$};
	\draw[thick] (v1) -- (w1) -- (v10) -- (v4) -- (v9);
	
	\node[fill=lime] (a1) at (-5.25, -6.5) {$a_0$};
	\node[fill=lime] (a2) at (-3.25, -6.5) {$a_1$};
	\node[fill=lime] (a3) at (-1.23, -6.5) {$a_2$};
	\node[fill=lime] (a4) at (1.25, -6.5) {$a_3$};
	\node[fill=lime] (a5) at (4, -6.5) {$a_4$};
	\draw (a1) -- (v5) (a2) -- (v6) (a3) -- (v7) (a4) -- (v8) (a5) -- (v9);
\end{tikzpicture}\]
\par Для доказу елемента з індексом $4$ достатньо лише одного елемента. На цьому прикладі бачимо, що розмір доказу включення $\ge 64$ байта, але $\le 64 \cdot \left(\lceil\log_2(n)\rceil - 1\right)$.

\subsection{Складність верифікації доказу включення.}
\par Верифікація доказу включення елемента в ІДМ взагалі не відрізняється від аналогічного для БДМ. В цьому випадку було вирішено подавати у функцію верифікації не тільки елемент і сформований для нього доказ, а і індекс елемента. Це спрощує код, зменшує кінцевий час роботи програми, але призводить до іншого недоліку -- неможна просто подати елемент і програма сама знайде його індекс. Код виглядає наступним чином:
\begin{lstlisting}
def indexed_proof_verification(x, k, y):
    L = []
    
    if x in leaves:
        L.append([hash(x), [k]])
        for i in range(len(y) - 1):
            if int(y[i][1][-1]) < int(L[i][1][-1]):
                L.append([hash(y[i][0] + L[i][0]), [*y[i][1], *L[i][1]]])
            else:
                L.append([hash(L[i][0] + y[i][0]), [*L[i][1], *y[i][1]]])
            
        if L[-1][0] == IMT[-2][0][0]:
            L.append([hash(L[-1][0] + y[-1][0]), [*L[-1][1], *y[-1][1]]])
        else:
            L.append([hash(y[-1][0] + L[-1][0]), [*y[-1][1], *L[-1][1]]])
    else:
        L.append([x, k])
        for i in range(len(y) - 1):
            if int(y[i][1][-1]) < int(L[i][1][-1]):
                L.append([hash(y[i][0] + L[i][0]), [*y[i][1], *L[i][1]]])
            else:
                L.append([hash(L[i][0] + y[i][0]), [*L[i][1], *y[i][1]]])
            
        if L[-1][0] == IMT[-2][0][0]:
            L.append([hash(L[-1][0] + y[-1][0]), [*L[-1][1], *y[-1][1]]])
        else:
            L.append([hash(y[-1][0] + L[-1][0]), [*y[-1][1], *L[-1][1]]])
            
    if L[-1][0] == IMT[-1][0][0]:
        return True
    else:
        return False
\end{lstlisting}

\par Для оцінки складності цього коду, пройдемо по ньому поетапно:
\begin{itemize}
	\item Пошук $x$ серед leaves займає в гіршому випадку $O(n)$ часу;
	\item Далі іде хешування елементів на кожному рівні, в гіршому випадку це займає $O(\log(n))$ часу
	\item Перевірка індексів має складність $O(1)$.
\end{itemize}
\par Як результат, маємо $O(n) + O(\log(n)) = O(n + \log(n))$.
\newline

\begin{table}[h]
	\captionsetup{labelformat=empty}
	\caption{\textbf{Порівняльна таблиця.}}
	\begin{center}
	\begin{tabular}{|c|c|c|c|}
		\hline
		& БДМ & РДМ & ІДМ \\
		\hline
		Додавання нового елемента & $O(n + k)$ & $O(n + k)$ & $O(n + k)$\\
		\hline
		Генерація доказу включення & $O(\log(n))$ & $O(n + \log(n)) $ & $O(n + \log(n))$ \\
		\hline
		Розмір доказу включення & $64 \cdot \big(\left\lceil \log_2(n)\right\rceil - 1\big)$ & $16320$ & $\le 64 \cdot \big(\left\lceil \log_2(n)\right\rceil - 1\big) $ \\
		\hline
		Верифікація доказу включення & $O(n)$ & $O(n + \log(n))$ & $O(n + \log(n))$ \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\end{document}